Introducing a new design pattern, that inverts the Decorator - the Decorated pattern. But first, some background on what the Decorator is.

Basically the idea is that you take a thing and you wrap it in a new thing. This "new thing" AKA the outer layer AKA the Decorator keeps a reference to the wrapped/decorated thing and copies all of its behaviours. Transparent Decorator would be a simple passthru to the decorated thing with no change in behaviour. This design is very phi, and trinitarian. What does trinitarian mean? I just made it up, so I'll explain that too. It alludes to the requirement for 3 distinct parts in the process of mutation. Those are: the original thing, the new thing being introduced, and the Whole that is the new thing plus the old thing. This is basically the idea of the Hegelian Dialectic. Anyway...enough with these fancy words. On to the Decorated pattern.

The Decorated pattern is the idea that you take a thing, give it a reference to an external thing, and copy the behaviour of the external thing onto the initial thing. But hold on, you might say, isn't this the exact same pattern as the Decorator? Sort of, but not exactly. It's a mutation of the existing thing - let's call this "Now" (because Now is a term that has the context of the flow/sequence of time, and this pattern is all about sequences). Now gets mutated to have Newness - New being the outer thing being linked to. In essence, what you are doing is making Now part of New, such that it can access New's stack of behaviour. The Whole is still the Whole, and can be discerned by walking outwardly in the New direction. But you're still playing with the instance of Now. Whereas with Decorator you are playing with New, which has a reference to Now. And if you want to access the Whole, you have to traverse inwardly in the Now direction. Make sense? Probably not if you don't code. But anyway...here we are.

Some interesting things about this pattern as it relates to other ideas in different domains - because Decorator/Phi is found everyfuckingwhere:

The "faith" that New exists (that a thing in the future exists) gives the Now the power of the New. Hahaha! Roll with that how you will. All you need is faith. Fill in your own blanks.

The process of Decorating and being Decorated are the same, but from different perspectives. The Current instance that is produced by this process is the difference.

In the case of the Decorator, the current instance is the New instance. The process being: instantiate New, give it a reference to Decorated, mutate New adding Decorated's behaviour. Sort of non-fluent, really, as you have to instantiate New first. You can't just flow from Now.

In the case of the Decorated, the current instance is the Now instance. The process being: you start with Now, give it a reference to New/Decorator, mutate Now adding Decorator's behaviour. This is fluent, as you're dealing with the same instance the whole (no pun intended) way through.

Decorated flows in sync with time. This is more natural/organic.

Decorated tackles the problem of Fluent Mutation with a single, consistently applied idiom.

Decorated/Decorator are essentially variations of LinkedLists with the behavioural mutations. With Decorator we are giving a thing a Next. With Decorated we are giving a thing a Previous.

Note that LinkedLists are the only pattern you need to build an Arithmetic Engine. An implementation of this can be found here - https://github.com/Piirtaa/Arith. This is a fascinating exercise if you're into this kinda thing.

Arithmetic engines/Counting are the precursor to language, if you think about it symbolically. You'll need a way to distinguish symbols consistently. Thus you'll need to "count" consistently.  

This might explain why Hebrew numbers its symbols.

This pattern also tangentially makes moot the whole (again no pun intended) Inheritance Vs Composition debate. It's not really much of a debate given that composition is literally infinitely superior.  This just describes how to do composition in a fluent way.

